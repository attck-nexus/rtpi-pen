#!/bin/bash

# RTPI-PEN Hosts Configuration Script
# Automatically configures /etc/hosts entries for clean service URLs
# Version: 1.0.0

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
HOSTS_FILE="/etc/hosts"
BACKUP_DIR="/opt/rtpi-pen/backups"
BACKUP_FILE="$BACKUP_DIR/hosts.backup.$(date +%Y%m%d_%H%M%S)"
RTPI_MARKER="# RTPI-PEN Service Entries"

# Logging functions
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $1${NC}"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1${NC}"
}

info() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')] INFO: $1${NC}"
}

# Display usage information
usage() {
    cat << EOF
RTPI-PEN Hosts Configuration Script

Usage: $0 [COMMAND] [OPTIONS]

Commands:
    add         Add RTPI-PEN service entries to /etc/hosts
    remove      Remove RTPI-PEN service entries from /etc/hosts
    restore     Restore /etc/hosts from backup
    show        Display current RTPI-PEN entries
    verify      Verify hostname resolution for RTPI-PEN services
    backup      Create backup of current /etc/hosts
    help        Show this help message

Options:
    --force     Force operation without confirmation
    --dry-run   Show what would be done without making changes

Examples:
    $0 add                    # Add RTPI-PEN hosts entries
    $0 remove --force         # Remove entries without confirmation
    $0 verify                 # Test hostname resolution
    $0 restore               # Restore from latest backup

Generated Host Entries:
    rtpi-pen.local           # Main dashboard
    kasm.rtpi.local          # Kasm Workspaces
    empire.rtpi.local        # Empire C2
    portainer.rtpi.local     # Container management
    sysreptor.rtpi.local     # Reporting platform
    registry.rtpi.local      # Docker registry
    healer.rtpi.local        # Self-healing API

Service Access URLs:
    https://kasm.rtpi.local:8443        # Kasm Workspaces
    http://empire.rtpi.local:1337       # Empire C2
    https://portainer.rtpi.local:9443   # Portainer
    http://sysreptor.rtpi.local:7777    # SysReptor
    http://healer.rtpi.local:8888       # Self-healing API
    http://registry.rtpi.local:5001     # Docker Registry

EOF
}

# Check if running as root
check_root() {
    if [ "$EUID" -ne 0 ]; then
        error "This script must be run as root to modify /etc/hosts"
        echo "Please run with: sudo $0 $*"
        exit 1
    fi
}

# Create backup directory
create_backup_dir() {
    if [ ! -d "$BACKUP_DIR" ]; then
        mkdir -p "$BACKUP_DIR"
        chmod 755 "$BACKUP_DIR"
        log "Created backup directory: $BACKUP_DIR"
    fi
}

# Create backup of hosts file
backup_hosts() {
    create_backup_dir
    
    if [ -f "$HOSTS_FILE" ]; then
        cp "$HOSTS_FILE" "$BACKUP_FILE"
        log "Hosts file backed up to: $BACKUP_FILE"
        return 0
    else
        error "Hosts file not found: $HOSTS_FILE"
        return 1
    fi
}

# Check if RTPI-PEN entries already exist
check_existing_entries() {
    if grep -q "$RTPI_MARKER" "$HOSTS_FILE" 2>/dev/null; then
        return 0  # Entries exist
    else
        return 1  # No entries found
    fi
}

# Generate RTPI-PEN hosts entries
generate_hosts_entries() {
    cat << EOF

$RTPI_MARKER
# Generated by RTPI-PEN configure-hosts.sh on $(date)
# Main RTPI-PEN entries
127.0.0.1       rtpi-pen.local
127.0.0.1       rtpi.local

# Core Services
127.0.0.1       kasm.rtpi.local
127.0.0.1       empire.rtpi.local
127.0.0.1       portainer.rtpi.local
127.0.0.1       sysreptor.rtpi.local
127.0.0.1       registry.rtpi.local
127.0.0.1       healer.rtpi.local

# Alternative short names
127.0.0.1       kasm.local
127.0.0.1       empire.local
127.0.0.1       portainer.local
127.0.0.1       sysreptor.local
127.0.0.1       reports.local

# Development/Admin interfaces
127.0.0.1       admin.rtpi.local
127.0.0.1       dashboard.rtpi.local
127.0.0.1       tools.rtpi.local
127.0.0.1       proxy.rtpi.local
# End RTPI-PEN Service Entries

EOF
}

# Add RTPI-PEN entries to hosts file
add_hosts() {
    local force="$1"
    local dry_run="$2"
    
    log "Adding RTPI-PEN hosts entries..."
    
    # Check if entries already exist
    if check_existing_entries; then
        if [ "$force" != "--force" ]; then
            warn "RTPI-PEN entries already exist in $HOSTS_FILE"
            echo "Use --force to overwrite existing entries"
            return 1
        else
            log "Removing existing entries before adding new ones"
            remove_hosts "--force" "$dry_run"
        fi
    fi
    
    if [ "$dry_run" = "--dry-run" ]; then
        info "DRY RUN: Would add the following entries to $HOSTS_FILE:"
        generate_hosts_entries
        return 0
    fi
    
    # Create backup
    backup_hosts
    
    # Add entries
    generate_hosts_entries >> "$HOSTS_FILE"
    
    log "✅ RTPI-PEN hosts entries added successfully!"
    info "Services are now accessible via:"
    echo "  • Kasm Workspaces: https://kasm.rtpi.local:8443"
    echo "  • Empire C2: http://empire.rtpi.local:1337"
    echo "  • Portainer: https://portainer.rtpi.local:9443"
    echo "  • SysReptor: http://sysreptor.rtpi.local:7777"
    echo "  • Self-Healing API: http://healer.rtpi.local:8888"
    echo "  • Docker Registry: http://registry.rtpi.local:5001"
}

# Remove RTPI-PEN entries from hosts file
remove_hosts() {
    local force="$1"
    local dry_run="$2"
    
    log "Removing RTPI-PEN hosts entries..."
    
    # Check if entries exist
    if ! check_existing_entries; then
        warn "No RTPI-PEN entries found in $HOSTS_FILE"
        return 1
    fi
    
    if [ "$force" != "--force" ] && [ "$dry_run" != "--dry-run" ]; then
        echo "This will remove all RTPI-PEN service entries from $HOSTS_FILE"
        read -p "Are you sure? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            info "Operation cancelled"
            return 1
        fi
    fi
    
    if [ "$dry_run" = "--dry-run" ]; then
        info "DRY RUN: Would remove RTPI-PEN entries from $HOSTS_FILE"
        show_hosts
        return 0
    fi
    
    # Create backup
    backup_hosts
    
    # Remove entries between markers
    sed -i "/$RTPI_MARKER/,/# End RTPI-PEN Service Entries/d" "$HOSTS_FILE"
    
    log "✅ RTPI-PEN hosts entries removed successfully!"
}

# Show current RTPI-PEN entries
show_hosts() {
    log "Current RTPI-PEN hosts entries:"
    
    if check_existing_entries; then
        grep -A 50 "$RTPI_MARKER" "$HOSTS_FILE" | grep -B 50 "# End RTPI-PEN Service Entries"
    else
        warn "No RTPI-PEN entries found in $HOSTS_FILE"
    fi
}

# Verify hostname resolution
verify_hosts() {
    log "Verifying RTPI-PEN hostname resolution..."
    
    local hostnames=(
        "rtpi-pen.local"
        "rtpi.local"
        "kasm.rtpi.local"
        "empire.rtpi.local"
        "portainer.rtpi.local"
        "sysreptor.rtpi.local"
        "registry.rtpi.local"
        "healer.rtpi.local"
        "kasm.local"
        "empire.local"
        "portainer.local"
        "sysreptor.local"
        "reports.local"
    )
    
    local failed=0
    
    for hostname in "${hostnames[@]}"; do
        if getent hosts "$hostname" >/dev/null 2>&1; then
            echo "✅ $hostname -> $(getent hosts "$hostname" | awk '{print $1}')"
        else
            echo "❌ $hostname (not resolved)"
            ((failed++))
        fi
    done
    
    if [ $failed -eq 0 ]; then
        log "✅ All hostnames resolved successfully!"
        
        # Test actual service connectivity
        log "Testing service connectivity..."
        test_service_connectivity
    else
        error "$failed hostnames failed to resolve"
        return 1
    fi
}

# Test service connectivity
test_service_connectivity() {
    local services=(
        "healer.rtpi.local:8888:/health"
        "kasm.rtpi.local:8443:/api/public/get_token"
        "portainer.rtpi.local:9443/"
        "sysreptor.rtpi.local:7777/"
        "registry.rtpi.local:5001/v2/"
    )
    
    info "Testing service connectivity..."
    
    for service in "${services[@]}"; do
        local hostname=$(echo "$service" | cut -d: -f1)
        local port=$(echo "$service" | cut -d: -f2)
        local path=$(echo "$service" | cut -d: -f3-)
        
        # Test if port is open
        if timeout 3 bash -c "</dev/tcp/$hostname/$port" 2>/dev/null; then
            echo "✅ $hostname:$port (port open)"
        else
            echo "⚠️  $hostname:$port (port not responding)"
        fi
    done
}

# Restore hosts file from backup
restore_hosts() {
    log "Restoring hosts file from backup..."
    
    # Find latest backup
    local latest_backup=$(ls -t "$BACKUP_DIR"/hosts.backup.* 2>/dev/null | head -n1)
    
    if [ -z "$latest_backup" ]; then
        error "No backup files found in $BACKUP_DIR"
        return 1
    fi
    
    echo "Latest backup: $latest_backup"
    read -p "Restore from this backup? (y/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        cp "$latest_backup" "$HOSTS_FILE"
        log "✅ Hosts file restored from: $latest_backup"
    else
        info "Restore cancelled"
    fi
}

# List available backups
list_backups() {
    log "Available hosts file backups:"
    
    if [ -d "$BACKUP_DIR" ]; then
        ls -la "$BACKUP_DIR"/hosts.backup.* 2>/dev/null || echo "No backup files found"
    else
        warn "Backup directory does not exist: $BACKUP_DIR"
    fi
}

# Main function
main() {
    local command="$1"
    local option1="$2"
    local option2="$3"
    
    case "$command" in
        add)
            check_root
            add_hosts "$option1" "$option2"
            ;;
        remove)
            check_root
            remove_hosts "$option1" "$option2"
            ;;
        restore)
            check_root
            restore_hosts
            ;;
        show)
            show_hosts
            ;;
        verify)
            verify_hosts
            ;;
        backup)
            check_root
            backup_hosts
            ;;
        list-backups)
            list_backups
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            error "Unknown command: $command"
            echo ""
            usage
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
